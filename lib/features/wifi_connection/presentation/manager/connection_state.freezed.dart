// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'connection_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ConnectionStates {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConnectionStatesCopyWith<$Res> {
  factory $ConnectionStatesCopyWith(
          ConnectionStates value, $Res Function(ConnectionStates) then) =
      _$ConnectionStatesCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConnectionStatesCopyWithImpl<$Res>
    implements $ConnectionStatesCopyWith<$Res> {
  _$ConnectionStatesCopyWithImpl(this._value, this._then);

  final ConnectionStates _value;
  // ignore: unused_field
  final $Res Function(ConnectionStates) _then;
}

/// @nodoc
abstract class _$$ConnectionIdleCopyWith<$Res> {
  factory _$$ConnectionIdleCopyWith(
          _$ConnectionIdle value, $Res Function(_$ConnectionIdle) then) =
      __$$ConnectionIdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionIdleCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$ConnectionIdleCopyWith<$Res> {
  __$$ConnectionIdleCopyWithImpl(
      _$ConnectionIdle _value, $Res Function(_$ConnectionIdle) _then)
      : super(_value, (v) => _then(v as _$ConnectionIdle));

  @override
  _$ConnectionIdle get _value => super._value as _$ConnectionIdle;
}

/// @nodoc

class _$ConnectionIdle implements ConnectionIdle {
  const _$ConnectionIdle();

  @override
  String toString() {
    return 'ConnectionStates.connectionIdle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConnectionIdle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return connectionIdle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return connectionIdle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionIdle != null) {
      return connectionIdle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return connectionIdle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return connectionIdle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionIdle != null) {
      return connectionIdle(this);
    }
    return orElse();
  }
}

abstract class ConnectionIdle implements ConnectionStates {
  const factory ConnectionIdle() = _$ConnectionIdle;
}

/// @nodoc
abstract class _$$ConnectionNoPermissionCopyWith<$Res> {
  factory _$$ConnectionNoPermissionCopyWith(_$ConnectionNoPermission value,
          $Res Function(_$ConnectionNoPermission) then) =
      __$$ConnectionNoPermissionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionNoPermissionCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$ConnectionNoPermissionCopyWith<$Res> {
  __$$ConnectionNoPermissionCopyWithImpl(_$ConnectionNoPermission _value,
      $Res Function(_$ConnectionNoPermission) _then)
      : super(_value, (v) => _then(v as _$ConnectionNoPermission));

  @override
  _$ConnectionNoPermission get _value =>
      super._value as _$ConnectionNoPermission;
}

/// @nodoc

class _$ConnectionNoPermission implements ConnectionNoPermission {
  const _$ConnectionNoPermission();

  @override
  String toString() {
    return 'ConnectionStates.connectionNoPermission()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConnectionNoPermission);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return connectionNoPermission();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return connectionNoPermission?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionNoPermission != null) {
      return connectionNoPermission();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return connectionNoPermission(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return connectionNoPermission?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionNoPermission != null) {
      return connectionNoPermission(this);
    }
    return orElse();
  }
}

abstract class ConnectionNoPermission implements ConnectionStates {
  const factory ConnectionNoPermission() = _$ConnectionNoPermission;
}

/// @nodoc
abstract class _$$CreateLocalNetworkCopyWith<$Res> {
  factory _$$CreateLocalNetworkCopyWith(_$CreateLocalNetwork value,
          $Res Function(_$CreateLocalNetwork) then) =
      __$$CreateLocalNetworkCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateLocalNetworkCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$CreateLocalNetworkCopyWith<$Res> {
  __$$CreateLocalNetworkCopyWithImpl(
      _$CreateLocalNetwork _value, $Res Function(_$CreateLocalNetwork) _then)
      : super(_value, (v) => _then(v as _$CreateLocalNetwork));

  @override
  _$CreateLocalNetwork get _value => super._value as _$CreateLocalNetwork;
}

/// @nodoc

class _$CreateLocalNetwork implements CreateLocalNetwork {
  const _$CreateLocalNetwork();

  @override
  String toString() {
    return 'ConnectionStates.createLocalNetwork()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CreateLocalNetwork);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return createLocalNetwork();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return createLocalNetwork?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (createLocalNetwork != null) {
      return createLocalNetwork();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return createLocalNetwork(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return createLocalNetwork?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (createLocalNetwork != null) {
      return createLocalNetwork(this);
    }
    return orElse();
  }
}

abstract class CreateLocalNetwork implements ConnectionStates {
  const factory CreateLocalNetwork() = _$CreateLocalNetwork;
}

/// @nodoc
abstract class _$$ConnectionPermissionGrantedCopyWith<$Res> {
  factory _$$ConnectionPermissionGrantedCopyWith(
          _$ConnectionPermissionGranted value,
          $Res Function(_$ConnectionPermissionGranted) then) =
      __$$ConnectionPermissionGrantedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionPermissionGrantedCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$ConnectionPermissionGrantedCopyWith<$Res> {
  __$$ConnectionPermissionGrantedCopyWithImpl(
      _$ConnectionPermissionGranted _value,
      $Res Function(_$ConnectionPermissionGranted) _then)
      : super(_value, (v) => _then(v as _$ConnectionPermissionGranted));

  @override
  _$ConnectionPermissionGranted get _value =>
      super._value as _$ConnectionPermissionGranted;
}

/// @nodoc

class _$ConnectionPermissionGranted implements ConnectionPermissionGranted {
  const _$ConnectionPermissionGranted();

  @override
  String toString() {
    return 'ConnectionStates.connectionPermissionGranted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionPermissionGranted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return connectionPermissionGranted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return connectionPermissionGranted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionPermissionGranted != null) {
      return connectionPermissionGranted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return connectionPermissionGranted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return connectionPermissionGranted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionPermissionGranted != null) {
      return connectionPermissionGranted(this);
    }
    return orElse();
  }
}

abstract class ConnectionPermissionGranted implements ConnectionStates {
  const factory ConnectionPermissionGranted() = _$ConnectionPermissionGranted;
}

/// @nodoc
abstract class _$$ConnectionActivateCopyWith<$Res> {
  factory _$$ConnectionActivateCopyWith(_$ConnectionActivate value,
          $Res Function(_$ConnectionActivate) then) =
      __$$ConnectionActivateCopyWithImpl<$Res>;
  $Res call({Map<String, String> connectedStudents});
}

/// @nodoc
class __$$ConnectionActivateCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$ConnectionActivateCopyWith<$Res> {
  __$$ConnectionActivateCopyWithImpl(
      _$ConnectionActivate _value, $Res Function(_$ConnectionActivate) _then)
      : super(_value, (v) => _then(v as _$ConnectionActivate));

  @override
  _$ConnectionActivate get _value => super._value as _$ConnectionActivate;

  @override
  $Res call({
    Object? connectedStudents = freezed,
  }) {
    return _then(_$ConnectionActivate(
      connectedStudents == freezed
          ? _value._connectedStudents
          : connectedStudents // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$ConnectionActivate implements ConnectionActivate {
  const _$ConnectionActivate(final Map<String, String> connectedStudents)
      : _connectedStudents = connectedStudents;

  final Map<String, String> _connectedStudents;
  @override
  Map<String, String> get connectedStudents {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_connectedStudents);
  }

  @override
  String toString() {
    return 'ConnectionStates.connectionActivate(connectedStudents: $connectedStudents)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionActivate &&
            const DeepCollectionEquality()
                .equals(other._connectedStudents, _connectedStudents));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_connectedStudents));

  @JsonKey(ignore: true)
  @override
  _$$ConnectionActivateCopyWith<_$ConnectionActivate> get copyWith =>
      __$$ConnectionActivateCopyWithImpl<_$ConnectionActivate>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return connectionActivate(connectedStudents);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return connectionActivate?.call(connectedStudents);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionActivate != null) {
      return connectionActivate(connectedStudents);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return connectionActivate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return connectionActivate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (connectionActivate != null) {
      return connectionActivate(this);
    }
    return orElse();
  }
}

abstract class ConnectionActivate implements ConnectionStates {
  const factory ConnectionActivate(
      final Map<String, String> connectedStudents) = _$ConnectionActivate;

  Map<String, String> get connectedStudents;
  @JsonKey(ignore: true)
  _$$ConnectionActivateCopyWith<_$ConnectionActivate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ModifyAttendedStudentsCopyWith<$Res> {
  factory _$$ModifyAttendedStudentsCopyWith(_$ModifyAttendedStudents value,
          $Res Function(_$ModifyAttendedStudents) then) =
      __$$ModifyAttendedStudentsCopyWithImpl<$Res>;
  $Res call({List<Map<String, dynamic>> attendedStudents});
}

/// @nodoc
class __$$ModifyAttendedStudentsCopyWithImpl<$Res>
    extends _$ConnectionStatesCopyWithImpl<$Res>
    implements _$$ModifyAttendedStudentsCopyWith<$Res> {
  __$$ModifyAttendedStudentsCopyWithImpl(_$ModifyAttendedStudents _value,
      $Res Function(_$ModifyAttendedStudents) _then)
      : super(_value, (v) => _then(v as _$ModifyAttendedStudents));

  @override
  _$ModifyAttendedStudents get _value =>
      super._value as _$ModifyAttendedStudents;

  @override
  $Res call({
    Object? attendedStudents = freezed,
  }) {
    return _then(_$ModifyAttendedStudents(
      attendedStudents == freezed
          ? _value._attendedStudents
          : attendedStudents // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
    ));
  }
}

/// @nodoc

class _$ModifyAttendedStudents implements ModifyAttendedStudents {
  const _$ModifyAttendedStudents(
      final List<Map<String, dynamic>> attendedStudents)
      : _attendedStudents = attendedStudents;

  final List<Map<String, dynamic>> _attendedStudents;
  @override
  List<Map<String, dynamic>> get attendedStudents {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_attendedStudents);
  }

  @override
  String toString() {
    return 'ConnectionStates.modifyAttendedStudents(attendedStudents: $attendedStudents)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModifyAttendedStudents &&
            const DeepCollectionEquality()
                .equals(other._attendedStudents, _attendedStudents));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_attendedStudents));

  @JsonKey(ignore: true)
  @override
  _$$ModifyAttendedStudentsCopyWith<_$ModifyAttendedStudents> get copyWith =>
      __$$ModifyAttendedStudentsCopyWithImpl<_$ModifyAttendedStudents>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connectionIdle,
    required TResult Function() connectionNoPermission,
    required TResult Function() createLocalNetwork,
    required TResult Function() connectionPermissionGranted,
    required TResult Function(Map<String, String> connectedStudents)
        connectionActivate,
    required TResult Function(List<Map<String, dynamic>> attendedStudents)
        modifyAttendedStudents,
  }) {
    return modifyAttendedStudents(attendedStudents);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
  }) {
    return modifyAttendedStudents?.call(attendedStudents);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connectionIdle,
    TResult Function()? connectionNoPermission,
    TResult Function()? createLocalNetwork,
    TResult Function()? connectionPermissionGranted,
    TResult Function(Map<String, String> connectedStudents)? connectionActivate,
    TResult Function(List<Map<String, dynamic>> attendedStudents)?
        modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (modifyAttendedStudents != null) {
      return modifyAttendedStudents(attendedStudents);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionIdle value) connectionIdle,
    required TResult Function(ConnectionNoPermission value)
        connectionNoPermission,
    required TResult Function(CreateLocalNetwork value) createLocalNetwork,
    required TResult Function(ConnectionPermissionGranted value)
        connectionPermissionGranted,
    required TResult Function(ConnectionActivate value) connectionActivate,
    required TResult Function(ModifyAttendedStudents value)
        modifyAttendedStudents,
  }) {
    return modifyAttendedStudents(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
  }) {
    return modifyAttendedStudents?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionIdle value)? connectionIdle,
    TResult Function(ConnectionNoPermission value)? connectionNoPermission,
    TResult Function(CreateLocalNetwork value)? createLocalNetwork,
    TResult Function(ConnectionPermissionGranted value)?
        connectionPermissionGranted,
    TResult Function(ConnectionActivate value)? connectionActivate,
    TResult Function(ModifyAttendedStudents value)? modifyAttendedStudents,
    required TResult orElse(),
  }) {
    if (modifyAttendedStudents != null) {
      return modifyAttendedStudents(this);
    }
    return orElse();
  }
}

abstract class ModifyAttendedStudents implements ConnectionStates {
  const factory ModifyAttendedStudents(
          final List<Map<String, dynamic>> attendedStudents) =
      _$ModifyAttendedStudents;

  List<Map<String, dynamic>> get attendedStudents;
  @JsonKey(ignore: true)
  _$$ModifyAttendedStudentsCopyWith<_$ModifyAttendedStudents> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StudentDateStates {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() studentDateInitialState,
    required TResult Function(List<Map<String, dynamic>> studentsDate)
        reloadedStudentsDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StudentDateInitialState value)
        studentDateInitialState,
    required TResult Function(ReloadedStudentsDate value) reloadedStudentsDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StudentDateStatesCopyWith<$Res> {
  factory $StudentDateStatesCopyWith(
          StudentDateStates value, $Res Function(StudentDateStates) then) =
      _$StudentDateStatesCopyWithImpl<$Res>;
}

/// @nodoc
class _$StudentDateStatesCopyWithImpl<$Res>
    implements $StudentDateStatesCopyWith<$Res> {
  _$StudentDateStatesCopyWithImpl(this._value, this._then);

  final StudentDateStates _value;
  // ignore: unused_field
  final $Res Function(StudentDateStates) _then;
}

/// @nodoc
abstract class _$$StudentDateInitialStateCopyWith<$Res> {
  factory _$$StudentDateInitialStateCopyWith(_$StudentDateInitialState value,
          $Res Function(_$StudentDateInitialState) then) =
      __$$StudentDateInitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StudentDateInitialStateCopyWithImpl<$Res>
    extends _$StudentDateStatesCopyWithImpl<$Res>
    implements _$$StudentDateInitialStateCopyWith<$Res> {
  __$$StudentDateInitialStateCopyWithImpl(_$StudentDateInitialState _value,
      $Res Function(_$StudentDateInitialState) _then)
      : super(_value, (v) => _then(v as _$StudentDateInitialState));

  @override
  _$StudentDateInitialState get _value =>
      super._value as _$StudentDateInitialState;
}

/// @nodoc

class _$StudentDateInitialState implements StudentDateInitialState {
  const _$StudentDateInitialState();

  @override
  String toString() {
    return 'StudentDateStates.studentDateInitialState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StudentDateInitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() studentDateInitialState,
    required TResult Function(List<Map<String, dynamic>> studentsDate)
        reloadedStudentsDate,
  }) {
    return studentDateInitialState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
  }) {
    return studentDateInitialState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
    required TResult orElse(),
  }) {
    if (studentDateInitialState != null) {
      return studentDateInitialState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StudentDateInitialState value)
        studentDateInitialState,
    required TResult Function(ReloadedStudentsDate value) reloadedStudentsDate,
  }) {
    return studentDateInitialState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
  }) {
    return studentDateInitialState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
    required TResult orElse(),
  }) {
    if (studentDateInitialState != null) {
      return studentDateInitialState(this);
    }
    return orElse();
  }
}

abstract class StudentDateInitialState implements StudentDateStates {
  const factory StudentDateInitialState() = _$StudentDateInitialState;
}

/// @nodoc
abstract class _$$ReloadedStudentsDateCopyWith<$Res> {
  factory _$$ReloadedStudentsDateCopyWith(_$ReloadedStudentsDate value,
          $Res Function(_$ReloadedStudentsDate) then) =
      __$$ReloadedStudentsDateCopyWithImpl<$Res>;
  $Res call({List<Map<String, dynamic>> studentsDate});
}

/// @nodoc
class __$$ReloadedStudentsDateCopyWithImpl<$Res>
    extends _$StudentDateStatesCopyWithImpl<$Res>
    implements _$$ReloadedStudentsDateCopyWith<$Res> {
  __$$ReloadedStudentsDateCopyWithImpl(_$ReloadedStudentsDate _value,
      $Res Function(_$ReloadedStudentsDate) _then)
      : super(_value, (v) => _then(v as _$ReloadedStudentsDate));

  @override
  _$ReloadedStudentsDate get _value => super._value as _$ReloadedStudentsDate;

  @override
  $Res call({
    Object? studentsDate = freezed,
  }) {
    return _then(_$ReloadedStudentsDate(
      studentsDate == freezed
          ? _value._studentsDate
          : studentsDate // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
    ));
  }
}

/// @nodoc

class _$ReloadedStudentsDate implements ReloadedStudentsDate {
  const _$ReloadedStudentsDate(final List<Map<String, dynamic>> studentsDate)
      : _studentsDate = studentsDate;

  final List<Map<String, dynamic>> _studentsDate;
  @override
  List<Map<String, dynamic>> get studentsDate {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_studentsDate);
  }

  @override
  String toString() {
    return 'StudentDateStates.reloadedStudentsDate(studentsDate: $studentsDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReloadedStudentsDate &&
            const DeepCollectionEquality()
                .equals(other._studentsDate, _studentsDate));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_studentsDate));

  @JsonKey(ignore: true)
  @override
  _$$ReloadedStudentsDateCopyWith<_$ReloadedStudentsDate> get copyWith =>
      __$$ReloadedStudentsDateCopyWithImpl<_$ReloadedStudentsDate>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() studentDateInitialState,
    required TResult Function(List<Map<String, dynamic>> studentsDate)
        reloadedStudentsDate,
  }) {
    return reloadedStudentsDate(studentsDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
  }) {
    return reloadedStudentsDate?.call(studentsDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? studentDateInitialState,
    TResult Function(List<Map<String, dynamic>> studentsDate)?
        reloadedStudentsDate,
    required TResult orElse(),
  }) {
    if (reloadedStudentsDate != null) {
      return reloadedStudentsDate(studentsDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StudentDateInitialState value)
        studentDateInitialState,
    required TResult Function(ReloadedStudentsDate value) reloadedStudentsDate,
  }) {
    return reloadedStudentsDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
  }) {
    return reloadedStudentsDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StudentDateInitialState value)? studentDateInitialState,
    TResult Function(ReloadedStudentsDate value)? reloadedStudentsDate,
    required TResult orElse(),
  }) {
    if (reloadedStudentsDate != null) {
      return reloadedStudentsDate(this);
    }
    return orElse();
  }
}

abstract class ReloadedStudentsDate implements StudentDateStates {
  const factory ReloadedStudentsDate(
      final List<Map<String, dynamic>> studentsDate) = _$ReloadedStudentsDate;

  List<Map<String, dynamic>> get studentsDate;
  @JsonKey(ignore: true)
  _$$ReloadedStudentsDateCopyWith<_$ReloadedStudentsDate> get copyWith =>
      throw _privateConstructorUsedError;
}
